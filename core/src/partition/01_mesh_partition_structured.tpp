#include "partition/01_mesh_partition.h"

#include "utility/vector_operators.h"
#include "basis_on_mesh/00_basis_on_mesh_base_dim.h"

namespace Partition
{
  
template<typename MeshType,typename BasisFunctionType>
MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
MeshPartition(std::array<global_no_t,MeshType::dim()> nElementsGlobal, std::shared_ptr<RankSubset> rankSubset) :
  MeshPartitionBase(rankSubset), nElementsGlobal_(nElementsGlobal), hasFullNumberOfNodes_({false})
{
  VLOG(1) << "create MeshPartition where only the global size is known, " 
    << "nElementsGlobal: " << nElementsGlobal_ << ", rankSubset: " << *rankSubset << ", mesh dimension: " << MeshType::dim();
  
  this->createDMElements();
  this->createDMNodes();
  
  this->initializeLocalDofsVector(nNodesLocalWithGhosts() * BasisOnMesh::BasisOnMeshBaseDim<MeshType::dim(),BasisFunctionType>::nDofsPerNode());
  
  LOG(DEBUG) << "nElementsLocal_: " << nElementsLocal_ << ", nElementsGlobal_: " << nElementsGlobal_
    << ", hasFullNumberOfNodes_: " << hasFullNumberOfNodes_;
  LOG(DEBUG) << "nRanks: " << nRanks_ << ", localSizesOnRanks_: " << localSizesOnRanks_ << ", beginElementGlobal_: " << beginElementGlobal_;
}

template<typename MeshType,typename BasisFunctionType>
MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
MeshPartition(std::array<node_no_t,MeshType::dim()> nElementsLocal, std::array<global_no_t,MeshType::dim()> nElementsGlobal, 
              std::array<int,MeshType::dim()> beginElementGlobal, 
              std::array<int,MeshType::dim()> nRanks, std::shared_ptr<RankSubset> rankSubset) :
  MeshPartitionBase(rankSubset), beginElementGlobal_(beginElementGlobal), nElementsLocal_(nElementsLocal), nElementsGlobal_(nElementsGlobal), 
  nRanks_(nRanks), hasFullNumberOfNodes_({false})
{
  // partitioning is already prescribed as every rank knows its own local size
 
  VLOG(1) << "create MeshPartition where every rank already knows its own local size. " 
    << "nElementsLocal: " << nElementsLocal << ", nElementsGlobal: " << nElementsGlobal 
    << ", beginElementGlobal: " << beginElementGlobal << ", nRanks: " << nRanks << ", rankSubset: " << *rankSubset;
    
  initializeHasFullNumberOfNodes();
  
  // determine localSizesOnRanks_
  for (int i = 0; i < MeshType::dim(); i++)
  {
    localSizesOnRanks_[i].resize(rankSubset->size());
  }
  
  for (int i = 0; i < MeshType::dim(); i++)
  {
    MPIUtility::handleReturnValue(MPI_Allgather(&nElementsLocal_[i], 1, MPI_INT, 
      localSizesOnRanks_[i].data(), rankSubset->size(), MPI_INT, rankSubset->mpiCommunicator()));
  }
  
  this->initializeLocalDofsVector(nNodesLocalWithGhosts() * BasisOnMesh::BasisOnMeshBaseDim<MeshType::dim(),BasisFunctionType>::nDofsPerNode());
  
  LOG(DEBUG) << *this;
  
  for (int i = 0; i < MeshType::dim(); i++)
  {
    LOG(DEBUG) << "  beginNodeGlobal(" << i << "): " << beginNodeGlobal(i);
  }
}

template<typename MeshType,typename BasisFunctionType>
void MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
initializeHasFullNumberOfNodes()
{
  // determine if the local partition is at the x+/y+/z+ border of the global domain
  for (int i = 0; i < MeshType::dim(); i++)
  {
    assert (beginElementGlobal_[i] + nElementsLocal_[i] <= nElementsGlobal_[i]);
    
    if (beginElementGlobal_[i] + nElementsLocal_[i] == nElementsGlobal_[i])
    {
      hasFullNumberOfNodes_[i] = true;
    }
  }
}

template<typename MeshType,typename BasisFunctionType>
void MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
createDmElements()
{
  typedef BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType> BasisOnMeshType;
 
  dmElements_ = std::make_shared<DM>();
  
  PetscErrorCode ierr;
  const int ghostLayerWidth = 1;
  const int nDofsPerElement = 1;   // a multiplicity parameter to the items for which the partitioning is generated by PETSc. 
  
  // create PETSc DMDA object that is a topology interface handling parallel data layout on structured grids
  if (MeshType::dim() == 1)
  {
    // create 1d decomposition
    ierr = DMDACreate1d(mpiCommunicator(), DM_BOUNDARY_NONE, globalSize_[0], nDofsPerElement, ghostLayerWidth, 
                        NULL, dmElements_.get()); CHKERRV(ierr);
    
    // get global coordinates of local partition
    PetscInt x, m;
    ierr = DMDAGetCorners(*dmElements_, &x, NULL, NULL, &m, NULL, NULL); CHKERRV(ierr);
    beginElementGlobal_[0] = (global_no_t)x;
    nElementsLocal_[0] = (element_no_t)m;
    
    // get number of ranks in each coordinate direction
    ierr = DMDAGetInfo(*dmElements_, NULL, NULL, NULL, NULL, &nRanks_[0], NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL); CHKERRV(ierr);
    
    // get local sizes on the ranks
    const PetscInt *lxData;
    ierr = DMDAGetOwnershipRanges(*dmElements_, &lxData, NULL, NULL);
    
    localSizesOnRanks_[0].assign(lxData,lxData+nRanks_[0]);
  }
  else if (MeshType::dim() == 2)
  {
    // create 2d decomposition
    ierr = DMDACreate2d(mpiCommunicator(), DM_BOUNDARY_NONE, DM_BOUNDARY_NONE, DMDA_STENCIL_BOX,
                        globalSize_[0], globalSize_[1], PETSC_DECIDE, PETSC_DECIDE,
                        nDofsPerElement, ghostLayerWidth, NULL, NULL, dmElements_.get()); CHKERRV(ierr);
                        
    // get global coordinates of local partition
    PetscInt x, y, m, n;
    ierr = DMDAGetCorners(*dmElements_, &x, &y, NULL, &m, &n, NULL); CHKERRV(ierr);
    beginElementGlobal_[0] = (global_no_t)x;
    beginElementGlobal_[1] = (global_no_t)y;
    nElementsLocal_[0] = (element_no_t)m;
    nElementsLocal_[1] = (element_no_t)n;
    
    // get number of ranks in each coordinate direction
    ierr = DMDAGetInfo(*dmElements_, NULL, NULL, NULL, NULL, &nRanks_[0], &nRanks_[1], NULL, NULL, NULL, NULL, NULL, NULL, NULL); CHKERRV(ierr);
    
    // get local sizes on the ranks
    const PetscInt *lxData;
    const PetscInt *lyData;
    ierr = DMDAGetOwnershipRanges(*dmElements_, &lxData, &lyData, NULL);
    localSizesOnRanks_[0].assign(lxData, lxData + nRanks_[0]);
    localSizesOnRanks_[1].assign(lyData, lyData + nRanks_[1]);
  }
  else if (MeshType::dim() == 3)
  {
    // create 3d decomposition
    ierr = DMDACreate3d(mpiCommunicator(), DM_BOUNDARY_NONE, DM_BOUNDARY_NONE, DM_BOUNDARY_NONE, DMDA_STENCIL_BOX,
                        globalSize_[0], globalSize_[1], globalSize_[2],
                        PETSC_DECIDE, PETSC_DECIDE, PETSC_DECIDE,
                        nDofsPerElement, ghostLayerWidth, NULL, NULL, NULL, dmElements_.get()); CHKERRV(ierr);
                        
    // get global coordinates of local partition
    PetscInt x, y, z, m, n, p;
    ierr = DMDAGetCorners(*dmElements_, &x, &y, &z, &m, &n, &p); CHKERRV(ierr);
    beginElementGlobal_[0] = (global_no_t)x;
    beginElementGlobal_[1] = (global_no_t)y;
    beginElementGlobal_[2] = (global_no_t)z;
    nElementsLocal_[0] = (element_no_t)m;
    nElementsLocal_[1] = (element_no_t)n;
    nElementsLocal_[2] = (element_no_t)p;
    
    // get number of ranks in each coordinate direction
    ierr = DMDAGetInfo(*dmElements_, NULL, NULL, NULL, NULL, &nRanks_[0], &nRanks_[1], &nRanks_[2], NULL, NULL, NULL, NULL, NULL, NULL); CHKERRV(ierr);
    
    // get local sizes on the ranks
    const PetscInt *lxData;
    const PetscInt *lyData;
    const PetscInt *lzData;
    ierr = DMDAGetOwnershipRanges(*dmElements_, &lxData, &lyData, &lzData);
    localSizesOnRanks_[0].assign(lxData, lxData + nRanks_[0]);
    localSizesOnRanks_[1].assign(lyData, lyData + nRanks_[1]);
    localSizesOnRanks_[2].assign(lzData, lzData + nRanks_[2]);
  }
  
  initializeHasFullNumberOfNodes();
}
  
//! get the local to global mapping for the current partition
template<typename MeshType,typename BasisFunctionType>
ISLocalToGlobalMapping MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
localToGlobalMappingDofs()
{
  // The local dofs number is unlike in OpenCMISS, where non-ghost and ghost numbers have their own contiguous range of local numbers.
  // Here the numbering is straight from 0 to nNodesLocalWithGhosts()-1, over non-ghost and ghost dofs together.
  
  ISLocalToGlobalMapping localToGlobalMapping;
  //DMGetLocalToGlobalMapping(*dmNodes_, &localToGlobalMapping);
  
  typedef BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType> BasisOnMeshType;
  const int nDofsPerNode = BasisOnMeshType::nDofsPerNode();
    
  // create a local to global dof no.s mapping
  PetscErrorCode ierr;
  std::vector<PetscInt> globalDofNos(nDofsLocalWithGhosts());  

  nonGhostDofLocalNos_.clear();
  nonGhostDofLocalNos_.reserve(nDofsLocalWithoutGhosts());
  
  // set the global dof nos for the local dofs
  if (MeshType::dim() == 1)
  {
    dof_no_t localDofNo = 0;
    for (dof_no_t i = beginNodeGlobal(0); i < beginNodeGlobal(0) + nNodesLocalWithGhosts(0); i++)
    {
      global_no_t globalDofNo = i * nDofsPerNode;
      
      bool dofIsNonGhost = i < beginNodeGlobal(0) + nNodesLocalWithoutGhosts(0);
        
      for (int dofIndex = 0; dofIndex < nDofsPerNode; dofIndex++)
      {
        globalDofNos[localDofNo] = (PetscInt)(globalDofNo + dofIndex);
        
        if (dofIsNonGhost)
        {
          nonGhostDofLocalNos_.push_back(localDofNo);
        }
        
        localDofNo++;
      }
    }
  }
  else if (MeshType::dim() == 2)
  {
    dof_no_t localDofNo = 0;
    for (dof_no_t j = beginNodeGlobal(1); j < beginNodeGlobal(1) + nNodesLocalWithGhosts(1); j++)
    {
      for (dof_no_t i = beginNodeGlobal(0); i < beginNodeGlobal(0) + nNodesLocalWithGhosts(0); i++)
      {
        global_no_t globalDofNo = (j * nNodesGlobal(0) + i) * nDofsPerNode;
        
        bool dofIsNonGhost = i < beginNodeGlobal(0) + nNodesLocalWithGhosts(0) 
          && j < beginNodeGlobal(1) + nNodesLocalWithGhosts(1);
          
        for (int dofIndex = 0; dofIndex < nDofsPerNode; dofIndex++)
        {
          globalDofNos[localDofNo] = (PetscInt)(globalDofNo + dofIndex);
          
          if (dofIsNonGhost)
          {
            nonGhostDofLocalNos_.push_back(localDofNo);
          }
          
          localDofNo++;
        }
      }
    }
  }
  else if (MeshType::dim() == 3)
  {
    dof_no_t localDofNo = 0;
    for (dof_no_t k = beginNodeGlobal(2); k < beginNodeGlobal(2) + nNodesLocalWithGhosts(2); k++)
    {
      for (dof_no_t j = beginNodeGlobal(1); j < beginNodeGlobal(1) + nNodesLocalWithGhosts(1); j++)
      {
        for (dof_no_t i = beginNodeGlobal(0); i < beginNodeGlobal(0) + nNodesLocalWithGhosts(0); i++)
        {
          global_no_t globalDofNo = (k * nNodesGlobal(1) * nNodesGlobal(0) + j * nNodesGlobal(0) + i) * nDofsPerNode;
        
          bool dofIsNonGhost = i < beginNodeGlobal(0) + nNodesLocalWithGhosts(0) 
            && j < beginNodeGlobal(1) + nNodesLocalWithGhosts(1)
            && k < beginNodeGlobal(2) + nNodesLocalWithGhosts(2);
              
          for (int dofIndex = 0; dofIndex < nDofsPerNode; dofIndex++)
          {
            globalDofNos[localDofNo] = (PetscInt)(globalDofNo + dofIndex);
            if (dofIsNonGhost)
            {
              nonGhostDofLocalNos_.push_back(localDofNo);
            }
            
            localDofNo++;
          }
        }
      }
    }
  }

  ierr = ISLocalToGlobalMappingCreate(mpiCommunicator(), 1, globalDofNos.size(), 
                                      globalDofNos.data(), PETSC_COPY_VALUES, &localToGlobalMapping); CHKERRABORT(mpiCommunicator(), ierr);

  return localToGlobalMapping;
}

//! return iterator to beginning of nonGhost dof nos
template<typename MeshType,typename BasisFunctionType>
std::vector<dof_no_t>::const_iterator MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
nonGhostDofsBegin()
{
  return nonGhostDofLocalNos_.cbegin();
}
  
//! return iterator to end of nonGhost dof nos
template<typename MeshType,typename BasisFunctionType>
std::vector<dof_no_t>::const_iterator MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
nonGhostDofsEnd()
{
  return nonGhostDofLocalNos_.cend();
}

template<typename MeshType,typename BasisFunctionType>
int MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
nRanks(int coordinateDirection)
{
  assert(0 <= coordinateDirection);
  assert(coordinateDirection < MeshType::dim());
  return nRanks_[coordinateDirection];
}

//! number of entries in the current partition
template<typename MeshType,typename BasisFunctionType>
element_no_t MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
nElementsLocal()
{
  element_no_t result = 1;
  for (int i = 0; i < MeshType::dim(); i++)
  {
    result *= nElementsLocal_[i];
  }
  return result;
}

template<typename MeshType,typename BasisFunctionType>
global_no_t MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
nElementsGlobal()
{
  global_no_t result = 1;
  for (int i = 0; i < MeshType::dim(); i++)
  {
    result *= nElementsGlobal_[i];
  }
  return result;
}

template<typename MeshType,typename BasisFunctionType>
dof_no_t MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
nDofsLocalWithGhosts()
{
  const int nDofsPerNode = BasisOnMeshType::nDofsPerNode();
  
  return nNodesLocalWithGhosts() * nDofsPerNode;
}

template<typename MeshType,typename BasisFunctionType>
dof_no_t MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
nDofsLocalWithoutGhosts()
{
  const int nDofsPerNode = BasisOnMeshType::nDofsPerNode();
  
  return nNodesLocalWithoutGhosts() * nDofsPerNode;
}

//! number of nodes in the local partition
template<typename MeshType,typename BasisFunctionType>
node_no_t MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
nNodesLocalWithGhosts()
{
  element_no_t result = 1;
  for (int i = 0; i < MeshType::dim(); i++)
  {
    result *= nNodesLocalWithGhosts(i);
  }
  return result;
}

//! number of nodes in the local partition
template<typename MeshType,typename BasisFunctionType>
node_no_t MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
nNodesLocalWithoutGhosts()
{
  element_no_t result = 1;
  for (int i = 0; i < MeshType::dim(); i++)
  {
    result *= nNodesLocalWithoutGhosts(i);
  }
  return result;
}

//! number of nodes in the local partition
template<typename MeshType,typename BasisFunctionType>
node_no_t MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
nNodesLocalWithGhosts(int coordinateDirection)
{
  assert(0 <= coordinateDirection);
  assert(coordinateDirection < MeshType::dim());
  
  return this->nElementsLocal_[coordinateDirection] * BasisOnMesh::BasisOnMeshBaseDim<1,BasisFunctionType>::averageNNodesPerElement() + 1;
}


//! number of nodes in the local partition
template<typename MeshType,typename BasisFunctionType>
node_no_t MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
nNodesLocalWithoutGhosts(int coordinateDirection)
{
  assert(0 <= coordinateDirection);
  assert(coordinateDirection < MeshType::dim());
  
  return this->nElementsLocal_[coordinateDirection] * BasisOnMesh::BasisOnMeshBaseDim<1,BasisFunctionType>::averageNNodesPerElement() 
    + (this->hasFullNumberOfNodes(coordinateDirection)? 1 : 0);
}

//! number of nodes in total
template<typename MeshType,typename BasisFunctionType>
global_no_t MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
nNodesGlobal()
{
  global_no_t result = 1;
  for (int i = 0; i < MeshType::dim(); i++)
  {
    result *= nNodesGlobal(i);
  }
  return result;
}

template<typename MeshType,typename BasisFunctionType>
node_no_t MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
beginNodeGlobal(int coordinateDirection)
{
  assert(0 <= coordinateDirection);
  assert(coordinateDirection < MeshType::dim());
  
  const int nNodesPer1DElement = BasisOnMesh::BasisOnMeshBaseDim<1,BasisFunctionType>::averageNNodesPerElement();
  return beginElementGlobal_[coordinateDirection] * nNodesPer1DElement;
}

//! number of nodes in total
template<typename MeshType,typename BasisFunctionType>
global_no_t MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
nNodesGlobal(int coordinateDirection)
{
  assert(0 <= coordinateDirection);
  assert(coordinateDirection < MeshType::dim());
  
  return nElementsGlobal_[coordinateDirection] * BasisOnMesh::BasisOnMeshBaseDim<1,BasisFunctionType>::averageNNodesPerElement() + 1; 
}
  
template<typename MeshType,typename BasisFunctionType>
global_no_t MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
globalSize(int coordinateDirection)
{
  assert(0 <= coordinateDirection);
  assert(coordinateDirection < MeshType::dim());
  return globalSize_[coordinateDirection];
}
  
//! get if there are nodes on both borders in the given coordinate direction
//! this is the case if the local partition touches the right/top/back border
template<typename MeshType,typename BasisFunctionType>
bool MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
hasFullNumberOfNodes(int coordinateDirection)
{
  assert(0 <= coordinateDirection);
  assert(coordinateDirection < MeshType::dim());
  
  return hasFullNumberOfNodes_[coordinateDirection];
}
  
template<typename MeshType,typename BasisFunctionType>
template<typename T>
void MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
extractLocalNodes(std::vector<T> &vector)
{
  std::vector<T> result(nNodesLocalWithGhosts());
  global_no_t resultIndex = 0;
  
  if (MeshType::dim() == 1)
  {
    assert(vector.size() >= beginNodeGlobal(0) + nNodesLocalWithGhosts(0));
    for (global_no_t i = beginNodeGlobal(0); i < beginNodeGlobal(0) + nNodesLocalWithGhosts(0); i++)
    {
      result[resultIndex++] = vector[i];
    }
  }
  else if (MeshType::dim() == 2)
  {
    for (global_no_t j = beginNodeGlobal(1); j < beginNodeGlobal(1) + nNodesLocalWithGhosts(1); j++)
    {
      for (global_no_t i = beginNodeGlobal(0); i < beginNodeGlobal(0) + nNodesLocalWithGhosts(0); i++)
      {
        result[resultIndex++] = vector[j*nNodesGlobal(0) + i];
      }
    }
  }
  else if (MeshType::dim() == 3)
  {
    for (global_no_t k = beginNodeGlobal(2); k < beginNodeGlobal(2) + nNodesLocalWithGhosts(2); k++)
    {
      for (global_no_t j = beginNodeGlobal(1); j < beginNodeGlobal(1) + nNodesLocalWithGhosts(1); j++)
      {
        for (global_no_t i = beginNodeGlobal(0); i < beginNodeGlobal(0) + nNodesLocalWithGhosts(0); i++)
        {
          result[resultIndex++] = vector[k*nNodesGlobal(1)*nNodesGlobal(0) + j*nNodesGlobal(0) + i];
        }
      }
    }
  }
  
  // store values
  vector.assign(result.begin(), result.end());
}
  
template<typename MeshType,typename BasisFunctionType>
void MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
extractLocalDofsWithoutGhosts(std::vector<double> &vector)
{
  dof_no_t nDofsPerNode = BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>::nDofsPerNode();
  std::vector<double> result(nLocalDofsWithoutGhosts());
  global_no_t resultIndex = 0;
  
  if (MeshType::dim() == 1)
  {
    assert(vector.size() >= beginNodeGlobal(0) + nNodesLocalWithGhosts(0));
    for (global_no_t i = beginNodeGlobal(0); i < beginNodeGlobal(0) + nNodesLocalWithoutGhosts(0); i++)
    {
      for (int dofOnNodeIndex = 0; dofOnNodeIndex < nDofsPerNode; dofOnNodeIndex++)
      {
        result[resultIndex++] = vector[i*nDofsPerNode + dofOnNodeIndex];
      }
    }
  }
  else if (MeshType::dim() == 2)
  {
    for (global_no_t j = beginNodeGlobal(1); j < beginNodeGlobal(1) + nNodesLocalWithoutGhosts(1); j++)
    {
      for (global_no_t i = beginNodeGlobal(0); i < beginNodeGlobal(0) + nNodesLocalWithoutGhosts(0); i++)
      {
        for (int dofOnNodeIndex = 0; dofOnNodeIndex < nDofsPerNode; dofOnNodeIndex++)
        {
          result[resultIndex++] = vector[(j*nNodesGlobal(0) + i)*nDofsPerNode + dofOnNodeIndex];
        }
      }
    }
  }
  else if (MeshType::dim() == 3)
  {
    for (global_no_t k = beginNodeGlobal(2); k < beginNodeGlobal(2) + nNodesLocalWithoutGhosts(2); k++)
    {
      for (global_no_t j = beginNodeGlobal(1); j < beginNodeGlobal(1) + nNodesLocalWithoutGhosts(1); j++)
      {
        for (global_no_t i = beginNodeGlobal(0); i < beginNodeGlobal(0) + nNodesLocalWithoutGhosts(0); i++)
        {
          for (int dofOnNodeIndex = 0; dofOnNodeIndex < nDofsPerNode; dofOnNodeIndex++)
          {
            result[resultIndex++] = vector[(k*nNodesGlobal(1)*nNodesGlobal(0) + j*nNodesGlobal(0) + i)*nDofsPerNode + dofOnNodeIndex];
          }
        }
      }
    }
  }
  
  // store values
  vector.assign(result.begin(), result.end());
}
 
template<typename MeshType,typename BasisFunctionType>
void MeshPartition<BasisOnMesh::BasisOnMesh<MeshType,BasisFunctionType>,Mesh::isStructured<MeshType>>::
output(std::ostream &stream)
{
  stream << "MeshPartition<structured>, nElementsGlobal: ";
  for (int i = 0; i < MeshType::dim(); i++)
    stream << nElementsGlobal_[i] << ",";
  
  stream << " nElementsLocal: ";
  for (int i = 0; i < MeshType::dim(); i++)
    stream << nElementsLocal_[i] << ",";
  
  stream << " nRanks: ";
  for (int i = 0; i < MeshType::dim(); i++)
    stream << nRanks_[i] << ",";
  
  stream << " beginElementGlobal: ";
  for (int i = 0; i < MeshType::dim(); i++)
    stream << beginElementGlobal_[i] << ",";
  
  stream << " hasFullNumberOfNodes: " ;
  for (int i = 0; i < MeshType::dim(); i++)
    stream << hasFullNumberOfNodes_[i] << ",";
  
  stream << " localSizesOnRanks: ";
  for (int i = 0; i < MeshType::dim(); i++)
    stream << localSizesOnRanks_[i] << ",";
  
  stream << " nNodesGlobal: ";
  for (int i = 0; i < MeshType::dim(); i++)
    stream << nNodesGlobal(i) << ",";
  stream << "total " << nNodesGlobal() << ",";
  
  stream << " nNodesLocalWithGhosts: ";
  for (int i = 0; i < MeshType::dim(); i++)
    stream << nNodesLocalWithGhosts(i) << ",";
  stream << "total " << nNodesLocalWithGhosts() << ",";
  
  stream << " nNodesLocalWithoutGhosts: ";
  for (int i = 0; i < MeshType::dim(); i++)
    stream << nNodesLocalWithoutGhosts(i) << ",";
  stream << "total " << nNodesLocalWithoutGhosts();
} 

}  // namespace