#include "specialized_solver/fast_monodomain_solver/fast_monodomain_solver_base.h"

#include "partition/rank_subset.h"
#include "control/diagnostic_tool/stimulation_logging.h"
#include <Vc/Vc>
#include <random>

template<int nStates, int nAlgebraics, typename DiffusionTimeSteppingScheme>
void FastMonodomainSolverBase<nStates,nAlgebraics,DiffusionTimeSteppingScheme>::
initializeCellMLSourceFileGpu()
{
  // only continue if optimization_type is gpu
  if (useVc_)
    return;

  // parse options
  CellmlAdapterType &cellmlAdapter = nestedSolvers_.instancesLocal()[0].timeStepping1().instancesLocal()[0].discretizableInTime();
  bool approximateExponentialFunction = cellmlAdapter.approximateExponentialFunction();

  PythonConfig specificSettingsCellML = cellmlAdapter.specificSettings();
  CellmlSourceCodeGenerator &cellmlSourceCodeGenerator = cellmlAdapter.cellmlSourceCodeGenerator();

  int ownRankNoCommWorld = DihuContext::ownRankNoCommWorld();

  // determine filename of library
  std::stringstream s;
  s << "lib/" << StringUtility::extractBasename(cellmlSourceCodeGenerator.sourceFilename())
    << "_fast_monodomain." << ownRankNoCommWorld << ".so";
  std::string libraryFilename = s.str();

  s.str("");
  s << "src/" << StringUtility::extractBasename(cellmlSourceCodeGenerator.sourceFilename())
    << "_fast_monodomain." << ownRankNoCommWorld << cellmlSourceCodeGenerator.sourceFileSuffix();
  std::string sourceToCompileFilename = s.str();

  // generate library
  LOG(DEBUG) << "generate source file \"" << sourceToCompileFilename << "\".";

  // create source file, without Vc but with normal "double" types
  const bool useVc = false;
  cellmlSourceCodeGenerator.generateSourceFileFastMonodomain(sourceToCompileFilename, approximateExponentialFunction, useVc);

  addMonodomainSolverGpuSource(sourceToCompileFilename);

  // create path for library file
  if (libraryFilename.find("/") != std::string::npos)
  {
    std::string path = libraryFilename.substr(0, libraryFilename.rfind("/"));
    int ret = system((std::string("mkdir -p ")+path).c_str());

    if (ret != 0)
    {
      LOG(ERROR) << "Could not create path \"" << path << "\" for library file.";
    }
  }

  // load compiler flags
  std::string compilerFlags = specificSettingsCellML.getOptionString("compilerFlags", "-O3 -march=native -fPIC -finstrument-functions -ftree-vectorize -fopt-info-vec-optimized=vectorizer_optimized.log -shared ");

#ifdef NDEBUG
  if (compilerFlags.find("-O3") == std::string::npos)
  {
    LOG(WARNING) << "\"compilerFlags\" does not contain \"-O3\", this may be slow.";
  }
  if (compilerFlags.find("-m") == std::string::npos)
  {
    LOG(WARNING) << "\"compilerFlags\" does not contain any \"-m\" flag, such as \"-march=native\". "
      << "Make sure that SIMD instructions sets (SEE, AVX-2 etc.) are the same in opendihu and the compiled library. \n"
      << " If unsure, use \"-O3 -march-native\".";
  }
#endif

  // compose compile command
  s.str("");
  s << cellmlSourceCodeGenerator.compilerCommand() << " " << sourceToCompileFilename << " "
    << compilerFlags << " " << cellmlSourceCodeGenerator.additionalCompileFlags() << " ";

  std::string compileCommandOptions = s.str();

  std::stringstream compileCommand;
  compileCommand << compileCommandOptions
    << " -o " << libraryFilename;

  int ret = system(compileCommand.str().c_str());
  if (ret != 0)
  {
    LOG(ERROR) << "Compilation failed. Command: \"" << compileCommand.str() << "\".";
  }
  else
  {
    LOG(DEBUG) << "Compilation successful. Command: \"" << compileCommand.str() << "\".";
  }

  // wait on all ranks until compilation is finished
  MPIUtility::handleReturnValue(MPI_Barrier(DihuContext::partitionManager()->rankSubsetForCollectiveOperations()->mpiCommunicator()), "MPI_Barrier");

  // load the rhs library
  void *handle = CellmlAdapterType::loadRhsLibraryGetHandle(libraryFilename);

  computeMonodomain_ = (void (*)(double [], std::vector<double> &, double, double)) dlsym(handle, "computeMonodomain");

  LOG(DEBUG) << "computeMonodomain_: " << (computeMonodomain_==nullptr? "no" : "yes");

  if (computeMonodomain_ == nullptr)
  {
    LOG(FATAL) << "Could not load functions from library \"" << libraryFilename << "\".";
  }
}

template<int nStates, int nAlgebraics, typename DiffusionTimeSteppingScheme>
void FastMonodomainSolverBase<nStates,nAlgebraics,DiffusionTimeSteppingScheme>::
addMonodomainSolverGpuSource(std::string outputFilename)
{
  // here, filename contains already c++ code generated from the cellML model that computes the 0D terms
  // we now add code to solve the whole monodomain equation

  std::stringstream sourceCode;
  sourceCode << "// the following code is generated by FastMonodomainSolver for offloading to GPU for "
    << nFibersToCompute_ << " fibers, " << nInstancesToCompute_ << " instances in total.";

  // define compute0D which computes one Heun step
  sourceCode
    << "// compute the 1D Crank-Nicolson or implicit euler step\n"
    << "#ifdef __cplusplus\n" << "extern \"C\"\n" << "#endif\n" << std::endl
    << "void compute1D(double states[], std::vector<double> &parameters, double currentTime, double timeStepWidth, bool stimulate,\n"
    << "               bool storeAlgebraicsForTransfer, std::vector<double> &algebraicsForTransfer, const std::vector<int> &algebraicsForTransferIndices, double valueForStimulatedPoint) \n"
    << "{\n";
    
  sourceCode << "}\n";

  sourceCode
    << "// compute the total monodomain equation\n"
    << "#ifdef __cplusplus\n" << "extern \"C\"\n" << "#endif\n" << std::endl
    << "void computeMonodomain_(double states[], std::vector<double> &parameters, double currentTime, double timeStepWidth, bool stimulate,\n"
    << "                        bool storeAlgebraicsForTransfer, std::vector<double> &algebraicsForTransfer, const std::vector<int> &algebraicsForTransferIndices, double valueForStimulatedPoint) \n"
    << "{\n";

  sourceCode << "}\n";
    
  // append to source file
  std::ofstream sourceCodeFile;
  OutputWriter::Generic::openFile(sourceCodeFile, outputFilename, true);
  if (!sourceCodeFile.is_open())
  {
    LOG(FATAL) << "Could not write to file \"" << outputFilename << "\".";
  }
  else
  {
    std::string fileContents = sourceCode.str();
    sourceCodeFile << fileContents;
    sourceCodeFile.close();
  }
}

template<int nStates, int nAlgebraics, typename DiffusionTimeSteppingScheme>
void FastMonodomainSolverBase<nStates,nAlgebraics,DiffusionTimeSteppingScheme>::
computeMonodomainGpu()
{
  
}
