CellML
=======


C++ code:

.. code-block:: c

  TimeSteppingScheme::ExplicitEuler<
    CellmlAdapter<57,1>  // nStates,nIntermediates: 57,1 = Shorten, 4,9 = Hodgkin Huxley
  >

The two template arguments of `CellmlAdapter` are the number of states and the number of intermediates. The number of intermediates has to be at least as big as the real number of intermediates because it is used to define buffers with the respective size. If the given value is higher, it will emit a warning. If it is too low, it will generate an error. Thus, you can figure out the needed value by testing a value and looking at the console output.

The CellML adapter can only be used with an explicit timestepping scheme, i.e. either `ExplicitEuler` or `Heun`.
  
Python settings:

.. code-block:: python

  "CellML": {
    "sourceFilename": cellml_file,              # input C++ source file, can be either generated by OpenCMISS or OpenCOR from cellml model
    "compilerFlags": "-fPIC -O3 -shared ",      # the compiler flags to be used to compile the cellml file to the library
    #"simdSourceFilename" : "simdcode.cpp",     # transformed C++ source file that gets generated from sourceFilename and is ready for multiple instances
    #"libraryFilename": "cellml_simd_lib.so",   # name of the compiled library
    "useGivenLibrary": False,                   # whether to use the existing library file under libraryFilename, if False, compile the given source file
    #"statesInitialValues": [],
    #"setSpecificParametersFunction": set_specific_parameters,    # callback function that sets parameters like stimulation current
    #"setSpecificParametersCallInterval": int(1./stimulation_frequency/dt_0D),     # set_parameters should be called every 0.1, 5e-5 * 1e3 = 5e-2 = 0.05
    "setSpecificStatesFunction": set_specific_states,    # callback function that sets states like Vm, activation can be implemented by using this method and directly setting Vm values, or by using setParameters/setSpecificParameters
    #"setSpecificStatesCallInterval": 2*int(1./stimulation_frequency/dt_0D),     # set_specific_states should be called stimulation_frequency times per ms, the factor 2 is needed because every Heun step includes two calls to rhs
    "setSpecificStatesCallInterval": 0,                  # 0 means disabled
    "setSpecificStatesCallFrequency": stimulation_frequency, # set_specific_states should be called stimulation_frequency times per ms, the factor 2 is needed because every Heun step includes two calls to rhs
    "setSpecificStatesRepeatAfterFirstCall": 0.01,  # simulation time span for which the setSpecificStates callback will be called after a call was triggered
    "additionalArgument": i,
    
    "outputIntermediateIndex": 0,  # which intermediate value to use in further computation
    "outputStateIndex": 0,     # Shorten / Hodgkin Huxley: state 0 = Vm, Shorten: rate 28 = gamma, intermediate 0 = gamma
    "parametersUsedAsIntermediate": parameters_used_as_intermediate,  #[32],       # list of intermediate value indices, that will be set by parameters. Explicitely defined parameters that will be copied to intermediates, this vector contains the indices of the algebraic array. This is ignored if the input is generated from OpenCMISS generated c code.
    "parametersUsedAsConstant": parameters_used_as_constant,          #[65],           # list of constant value indices, that will be set by parameters. This is ignored if the input is generated from OpenCMISS generated c code.
    "parametersInitialValues": parameters_initial_values,            #[0.0, 1.0],      # initial values for the parameters: I_Stim, l_hs
    "meshName": "MeshFiber_{}".format(fiber_no(subdomain_coordinate_x, subdomain_coordinate_y, fiber_in_subdomain_coordinate_x, fiber_in_subdomain_coordinate_y)),
    "prefactor": 1.0,
  }
  
(Todo: explain the options, especially the callback functionality)
